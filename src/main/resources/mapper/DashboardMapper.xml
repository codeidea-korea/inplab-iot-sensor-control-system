<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    
<mapper namespace="com.safeone.dashboard.dao.DashboardMapper">
    <select id="selectAlarm" parameterType="java.util.Map" resultType="java.util.Map">
        select
            alarm_uid,
            ta.reg_date,
            ta.risk_level,
            fn_common(ta.risk_level::integer, '위험레벨') as risk_name,
            fn_common(ta.alarm_type::integer, '알람종류타입') as alarm_type,
            ta.alarm_desc,
            ta.alarm_title,
            fn_common(tak2.status::integer, '센서상태') as asset_status,
            tak2.asset_id,
            tak2."name" as asset_name,
            tak3."name" as asset_kind_name,
            tak2.etc1,
            tak2.x,
            tak2.y,
            tz.zone_id,
            tz."name" as zone_name,
            tz.etc1 as zone_etc1,
            tz.lat,
            tz.lng,
            tz.file1,
            tz.file2
        from tb_alarm ta, tb_asset tak2, tb_asset_kind tak3, tb_zone tz 
        where ta.asset_id = tak2.asset_id 
          and tak2.zone_id = tz.zone_id     
          and tak2.asset_kind_id = tak3.asset_kind_id 
        <if test="reg_date != null and reg_date != ''">
            <![CDATA[
            and ta.reg_date > to_timestamp(#{reg_date}::numeric / 1000)
            ]]>
        </if>
        order by reg_date desc
        limit 5
    </select>

    <select id="selectAreaInfo" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT
            tdi.district_no,
            tdi.site_no,
            tdi.district_nm,
            tdi.dist_addr,
            tdi.dist_road_addr,
            tdi.dist_type_cd,
            tdi.dist_pic,
            tdi.dist_view_pic,
            tdi.dist_lon,
            tdi.dist_lat,
            tdi.inst_comp_id1,
            tmi1.partner_comp_nm AS inst_comp_nm1,
            tdi.meas_comp_id1,
            tmi2.partner_comp_nm AS meas_comp_nm1,
            tdi.inst_comp_id2,
            tmi3.partner_comp_nm AS inst_comp_nm2,
            tdi.meas_comp_id2,
            tmi4.partner_comp_nm AS meas_comp_nm2,
            tdi.meas_str_ymd,
            tdi.meas_end_ymd,
            tdi.dist_offi_nm,
            tdi.reg_dt,
            tdi.mod_dt,
            tdi.dist_zip,
            tdi.dist_zoom
        FROM tb_district_info tdi
        LEFT JOIN tb_maintcomp_info tmi1 ON tmi1.partner_comp_id = tdi.inst_comp_id1
        LEFT JOIN tb_maintcomp_info tmi2 ON tmi2.partner_comp_id = tdi.meas_comp_id1
        LEFT JOIN tb_maintcomp_info tmi3 ON tmi3.partner_comp_id = tdi.inst_comp_id2
        LEFT JOIN tb_maintcomp_info tmi4 ON tmi4.partner_comp_id = tdi.meas_comp_id2
        WHERE 1=1
        <if test="district_no != null and district_no != ''">
            and district_no = #{district_no}
        </if>
    </select>

    <select id="selectDashboardData" parameterType="java.util.Map" resultType="java.util.Map">
        select * from tb_dashboarddata
        where 1=1
        <choose>
            <when test="cdate != null and cdate != ''">
        <![CDATA[
                and _cdate > #{cdate}
        ]]>
            </when>
            <otherwise>
        <![CDATA[            
                and _cdate::timestamp > now() - interval '24 hour'
        ]]>
            </otherwise>
        </choose>
        order by "_cdate" asc
        limit 5
    </select>

    <select id="selectAssetAlarm" parameterType="java.util.Map" resultType="java.util.Map">
        select 
            ta.asset_id,
            ta.area_id,
            ta.zone_id,	
            max(ta2.risk_level) as risk_level
        <![CDATA[
            from tb_asset ta left outer join (select * from tb_alarm where reg_date::timestamp >= now() - interval '1 minutes') ta2 on ta.asset_id = ta2.asset_id 
        ]]>
        group by ta.asset_id, ta.area_id, ta.zone_id
    </select>

    <select id="selectMarkerList" parameterType="java.util.Map" resultType="java.util.Map">
        select
            ta.asset_id
             , ta.name as asset_name
             , ta.etc1
             , ta.area_id
             , ta.zone_id
             , ta.status
             , tak.name
             , tak.description
             , ta.x
             , ta.y
        from tb_asset ta, tb_asset_kind tak 
        where ta.asset_kind_id = tak.asset_kind_id 
        <if test="zone_id != null and zone_id != ''">
            and ta.zone_id = #{zone_id}
        </if>
    </select>

    <select id="selectSensorCountByStatus" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT count(*) as total_cnt
             , count(CASE WHEN status = '1' THEN 1 END) AS receive_cnt
             , count(CASE WHEN status = '2' THEN 1 END) AS not_receive_cnt
        FROM tb_asset
        WHERE asset_kind_id IN ('2','3','4','6','7')
    </select>

    <select id="selectCCTVCountByStatus" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT count(*) as total_cnt
             , count(CASE WHEN status = '1' THEN 1 END) AS receive_cnt
             , count(CASE WHEN status = '2' THEN 1 END) AS not_receive_cnt
        FROM tb_asset
        WHERE asset_kind_id = '8'
    </select>

    <select id="selectSystemCountByStatus" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT
            CASE
                WHEN ta.asset_kind_id IN ('2', '3', '4', '6', '7') THEN '2-7'
                ELSE ta.asset_kind_id
                END AS grouped_asset_kind_id,
            COUNT(*) AS total_count,
            COUNT(CASE WHEN ta.status = '1' THEN 1 END) AS status_1_count,
            COUNT(CASE WHEN ta.status = '2' THEN 1 END) AS status_2_count
        FROM
            tb_asset ta
        left join tb_zone tz on (ta.zone_id = tz.zone_id)
        WHERE 1=1
            and ta.asset_kind_id IN ('2', '3', '4', '6', '7', '8')
            and tz.use_flag = 'Y'
        GROUP BY
            grouped_asset_kind_id
        ORDER BY
            grouped_asset_kind_id
    </select>

    <select id="selectSensorChartData" parameterType="java.util.Map" resultType="java.util.Map">
        WITH TimeSlotData AS (
            SELECT
                mng.manage_id,
                mng.standard_time,
                mng.min1,
                mng.min2,
                mng.min3,
                mng.min4,
                mng.max1,
                mng.max2,
                mng.max3,
                mng.max4,
                mng.sensor_id,
                mng.zone_id,
                ch.channel_id,
                ch."name" as channel_name,
                ch.asset_id,
                ass.asset_kind_id,
                tak.name as asset_kind_name,
                ass."name" AS asset_name,
                ass.etc1,
                ass.etc2,
                ass.area_id,
                tdb.real_value,
                TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS') as collect_date,
                tdb.calc_value,
                tdb.raw_value,
                tdb."type",
                #{itv} as intervalValue,
                <choose>
                    <when test="itv.equals('4hour')">
                        date_trunc('day', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) + floor(extract(hour from TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) / 4.0) * 4 * interval '1 hour' as time_slot
                    </when>
                    <when test="itv.equals('hour')">
                        date_trunc('hour', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) +
                        (((date_part('minute', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS'))::integer / 60) * 60) || ' minutes')::interval AS time_slot
                    </when>
                    <when test="itv.equals('5min')">                        
                        date_trunc('hour', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) +
                            (((date_part('minute', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS'))::integer / 5) * 5) || ' minutes')::interval AS time_slot
                    </when>
                    <otherwise>
                        date_trunc('hour', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) +
                            (((date_part('minute', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS'))::integer / 1) * 1) || ' minutes')::interval AS time_slot
                    </otherwise>
                </choose>
            FROM tb_manage mng
                LEFT JOIN tb_channel ch ON mng.sensor_id = ch.sensor_id and mng.zone_id = ch.zone_id
                LEFT JOIN tb_asset ass ON ch.asset_id = ass.asset_id
                LEFT OUTER JOIN tb_dps_basecollection tdb ON mng.zone_id = tdb.zone_id and mng.sensor_id = tdb.sensor_id
                left outer join tb_asset_kind tak on ass.asset_kind_id = tak.asset_kind_id 
            <![CDATA[    
            WHERE TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS') >= #{start_date}::timestamp AND
                TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS') <= '${end_date} 23:59:59'
            ]]>
        )
        select distinct
            tsd.asset_id,
            tsd.time_slot,
            to_char(tsd.time_slot, 'YYYY-MM-DD HH24:MI:SS') as data_time,
            tsd.asset_kind_id,
            tsd.asset_kind_name,
            tsd.asset_name,
            tsd.channel_id,
            tsd.channel_name,
            tsd.min1,
            tsd.min2,
            tsd.min3,
            tsd.min4,
            tsd.max1,
            tsd.max2,
            tsd.max3,
            tsd.max4,
            <choose>
                <when test="valueType.equals('raw')">
                    AVG(raw_value::float) OVER (PARTITION BY time_slot, tsd.asset_id) AS avg_value,
                    MIN(raw_value::float) OVER (PARTITION BY time_slot, tsd.asset_id) AS min_value,
                    MAX(raw_value::float) OVER (PARTITION BY time_slot, tsd.asset_id) AS max_value,
                    FIRST_VALUE(raw_value::float) OVER (PARTITION BY time_slot, tsd.asset_id ORDER BY collect_date) AS start_value,
                    LAST_VALUE(raw_value::float) OVER (PARTITION BY time_slot, tsd.asset_id ORDER BY collect_date RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS end_value,
                    FIRST_VALUE(raw_value) OVER (order by raw_value::float desc) AS tar_value
                </when>
                <otherwise>
                    AVG(real_value::float) OVER (PARTITION BY time_slot, tsd.asset_id) AS avg_value,
                    MIN(real_value::float) OVER (PARTITION BY time_slot, tsd.asset_id) AS min_value,
                    MAX(real_value::float) OVER (PARTITION BY time_slot, tsd.asset_id) AS max_value,
                    FIRST_VALUE(real_value::float) OVER (PARTITION BY time_slot, tsd.asset_id ORDER BY collect_date) AS start_value,
                    LAST_VALUE(real_value::float) OVER (PARTITION BY time_slot, tsd.asset_id ORDER BY collect_date RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS end_value,
                    FIRST_VALUE(real_value) OVER (order by real_value::float desc) AS tar_value
                </otherwise>
            </choose>
        FROM TimeSlotData tsd
        where asset_id in 
        <foreach item="asset_id" collection="asset_ids" open="(" separator="," close=")">
            #{asset_id}::varchar
        </foreach>        
        ORDER BY asset_id, channel_id, time_slot
    </select>

    <select id="selectSensorChartRealData" parameterType="java.util.Map" resultType="java.util.Map">
        WITH TimeSlotData AS (
            SELECT
                mng.manage_id,
                mng.standard_time,
                mng.min1,
                mng.min2,
                mng.min3,
                mng.min4,
                mng.max1,
                mng.max2,
                mng.max3,
                mng.max4,
                mng.sensor_id,
                mng.zone_id,
                ch.channel_id,
                ch."name" as channel_name,
                ch.asset_id,
                ass.asset_kind_id,
                tak.name as asset_kind_name,
                ass."name" AS asset_name,
                ass.etc1,
                ass.etc2,
                ass.area_id,
                tdb.real_value,
                TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS') as collect_date,
                tdb.calc_value,
                tdb.raw_value,
                tdb."type",
                #{itv} as intervalValue,
                <choose>
                    <when test="itv.equals('4hour')">
                        date_trunc('day', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) + floor(extract(hour from TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) / 4.0) * 4 * interval '1 hour' as time_slot
                    </when>
                    <when test="itv.equals('hour')">
                        date_trunc('hour', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) +
                        (((date_part('minute', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS'))::integer / 60) * 60) || ' minutes')::interval AS time_slot
                    </when>
                    <when test="itv.equals('5min')">
                        date_trunc('hour', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) +
                            (((date_part('minute', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS'))::integer / 5) * 5) || ' minutes')::interval AS time_slot
                    </when>
                    <otherwise>
                        date_trunc('hour', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS')) +
                            (((date_part('minute', TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS'))::integer / 1) * 1) || ' minutes')::interval AS time_slot
                    </otherwise>
                </choose>
            FROM tb_manage mng
                LEFT JOIN tb_channel ch ON mng.sensor_id = ch.sensor_id and mng.zone_id = ch.zone_id
                LEFT JOIN tb_asset ass ON ch.asset_id = ass.asset_id
                LEFT OUTER JOIN tb_dps_basecollection tdb ON mng.zone_id = tdb.zone_id and mng.sensor_id = tdb.sensor_id
                left outer join tb_asset_kind tak on ass.asset_kind_id = tak.asset_kind_id
            <![CDATA[
            WHERE TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS') >= #{start_date}::timestamp AND
                TO_TIMESTAMP(tdb.collect_date , 'YYYY/MM/DD HH24:MI:SS') <= '${end_date} 23:59:59'
            ]]>
        )
        select distinct
            tsd.asset_id,
            tsd.time_slot,
            to_char(tsd.time_slot, 'YYYY-MM-DD HH24:MI:SS') as data_time,
            tsd.asset_kind_id,
            tsd.asset_kind_name,
            tsd.asset_name,
            tsd.channel_id,
            tsd.channel_name,
            tsd.min1,
            tsd.min2,
            tsd.min3,
            tsd.min4,
            tsd.max1,
            tsd.max2,
            tsd.max3,
            tsd.max4,
            tsd.real_value::float AS real_value,
            FIRST_VALUE(tsd.real_value) OVER (order by tsd.real_value::float desc) AS tar_value
        FROM TimeSlotData tsd
        where asset_id in
        <foreach item="asset_id" collection="asset_ids" open="(" separator="," close=")">
            #{asset_id}::varchar
        </foreach>
        ORDER BY asset_id, channel_id, time_slot
    </select>


    <select id="selectDeviceCount" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT
            c.cctv_count,
            s.ttm_count,
            s.ttw_count,
            s.gnss_count,
            s.tm_count,
            s.rain_count
        FROM (
                 SELECT COUNT(*) AS cctv_count
                 FROM tb_cctv_info
                 WHERE del_yn IS DISTINCT FROM 'Y'
                <if test="district_no != null and district_no != ''">
                    and district_no = #{district_no}
                </if>
             ) c
                 CROSS JOIN (
            SELECT
                COUNT(*) FILTER (WHERE tsi.sens_nm LIKE 'TTM%')  AS ttm_count,
                    COUNT(*) FILTER (WHERE tsi.sens_nm LIKE 'TTW%')  AS ttw_count,
                    COUNT(*) FILTER (WHERE tsi.sens_nm LIKE 'GNSS%') AS gnss_count,
                    COUNT(*) FILTER (WHERE tsi.sens_nm LIKE 'TM%')   AS tm_count,
                    COUNT(*) FILTER (WHERE tsi.sens_nm LIKE 'RAIN%') AS rain_count
            FROM tb_sensor_info tsi
            <if test="district_no != null and district_no != ''">
                join tb_logger_info tli on tsi.logr_no = tli.logr_no and tli.district_no= #{district_no}
            </if>
        ) s;
    </select>

    <select id="selectDetailSystemCountByStatus" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT
            ta.asset_kind_id,
            COUNT(*) AS total_count,
            COUNT(CASE WHEN ta.status = '1' THEN 1 END) AS status_1_count,
            COUNT(CASE WHEN ta.status = '2' THEN 1 END) AS status_2_count
        FROM
            tb_asset ta
        left join tb_zone tz on (ta.zone_id = tz.zone_id)
        WHERE 1=1
            and ta.asset_kind_id IN ('2','3','4','6','7','8')
            and tz.use_flag = 'Y'
        <if test="zone_id != null and zone_id != ''">
            and ta.zone_id = #{zone_id}
        </if>
        GROUP BY
            ta.asset_kind_id
        order by
            ta.asset_kind_id
    </select>

    <select id="selectMaintenanceInfo" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT MG.*
        FROM (
             SELECT
                 A.manager_name
                  , (select "name" from tb_common_code_old where category = '유지보수종류' and code = A.type::int  ) AS type_name
                  , asset.name as asset_name
                  , asset.zone_id
                  , A.reg_date
             FROM tb_maintenance A
                      LEFT OUTER JOIN tb_asset asset ON A.asset_id = asset.asset_id
             ) MG
        WHERE 1=1
        <if test="zone_id != null and zone_id != ''">
            and MG.zone_id = #{zone_id}
        </if>
        order by MG.reg_date desc
    </select>

    <select id="getAlarmHistory" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT
            tad.sens_no,
            tad.meas_dt,
            tsi.sens_nm,
            tdi.district_nm,
            tad.sens_chnl_id,
            tad.alarm_lvl_cd,
            tad.formul_data,
            tad.net_err_yn,
            tad.maint_sts_cd,
            tai."1st_lvl_max" AS max1,
            tai."1st_lvl_min" AS min1,
            tai."2nd_lvl_max" AS max2,
            tai."2nd_lvl_min" AS min2,
            tai."3rd_lvl_max" AS max3,
            tai."3rd_lvl_min" AS min3,
            tai."4th_lvl_max" AS max4,
            tai."4th_lvl_min" AS min4,
            tad.reg_dt,
            tst.sens_tp_nm,
            tsc.sens_chnl_nm
        FROM tb_alarm_details tad
                 LEFT JOIN tb_district_info tdi
                           ON tad.district_no = tdi.district_no
                 LEFT JOIN tb_sensor_info tsi
                           ON tad.sens_no = tsi.sens_no
                 LEFT JOIN tb_alarm_info tai
                           ON tad.sens_no = tai.sens_no
                 LEFT JOIN tb_sensor_type tst
                           ON tsi.senstype_no = tst.senstype_no
                 LEFT JOIN  tb_sensor_chnl tsc
                           ON tad.sens_no = tsc.sens_no
                           AND tad.sens_chnl_id = tsc.sens_chnl_id
        WHERE 1=1
            <if test="district_no != null and district_no != ''">
                and tad.district_no = #{district_no}
            </if>
        order by tad.reg_dt desc
    </select>

    <select id="getAlarmMessage" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT
            tad.mgnt_no,
            tad.sens_no,
            tad.meas_dt,
            tsi.sens_nm,
            tdi.district_nm,
            tad.sens_chnl_id,
            tad.alarm_lvl_cd,
            tad.formul_data,
            tad.net_err_yn,
            tad.maint_sts_cd,
            tai."1st_lvl_max" AS max1,
            tai."1st_lvl_min" AS min1,
            tai."2nd_lvl_max" AS max2,
            tai."2nd_lvl_min" AS min2,
            tai."3rd_lvl_max" AS max3,
            tai."3rd_lvl_min" AS min3,
            tai."4th_lvl_max" AS max4,
            tai."4th_lvl_min" AS min4,
            tad.reg_dt,
            tst.sens_tp_nm,
            tad.view_flag
        FROM tb_alarm_details tad
        LEFT JOIN tb_district_info tdi
        ON tad.district_no = tdi.district_no
        LEFT JOIN tb_sensor_info tsi
        ON tad.sens_no = tsi.sens_no
        LEFT JOIN tb_alarm_info tai
        ON tad.sens_no = tai.sens_no
        LEFT JOIN tb_sensor_type tst
        ON tsi.senstype_no = tst.senstype_no
        WHERE 1=1
            and tad.view_flag = #{view_flag}
        order by tad.reg_dt desc
        limit 6
    </select>

    <update id="updateViewFlag" parameterType="java.lang.Integer">
        update tb_alarm_details
        set view_flag = 'Y'
        where mgnt_no = #{mgntNo}
    </update>

    <select id="getSensorList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT
            c.district_nm,
            a.sens_no,
            a.senstype_no,
            d.sens_tp_nm,
            a.sens_nm,
            b.logr_nm,
            a.sect_no,
            TO_CHAR(TO_DATE(a.inst_ymd, 'YYYYMMDD'), 'YYYY-MM-DD') AS inst_ymd,
            md.meas_dt AS latest_meas_dt,
            COALESCE(m.maint_rslt_cd, 'MTN001') AS sens_status,
            CASE
            WHEN COALESCE(EXTRACT(EPOCH FROM (now() - md.meas_dt)) / 60, 999999) >= a.nonrecv_limit_min THEN '미수신'
            ELSE '수신'
            END AS comm_status,
            md.formul_data
        FROM tb_sensor_info a
        JOIN tb_logger_info b ON a.logr_no = b.logr_no
        JOIN tb_district_info c ON b.district_no = c.district_no
        JOIN tb_sensor_type d ON a.senstype_no = d.senstype_no
        LEFT JOIN LATERAL (
            SELECT meas_dt, formul_data
            FROM tb_measure_details m
            WHERE m.sens_no = a.sens_no
            ORDER BY m.meas_dt DESC
            LIMIT 1
        ) md ON TRUE
        LEFT JOIN LATERAL (
            SELECT maint_rslt_cd
            FROM tb_maint_details m2
            WHERE m2.sens_no = a.sens_no
            ORDER BY m2.maint_accpt_ymd DESC
            LIMIT 1
        ) m ON TRUE
        where a.sens_disp_yn ='Y'
        ORDER BY c.district_nm, a.senstype_no, a.sens_no
        <if test="limit != null and !limit.equals('') and offset != null and !offset.equals('')">
            LIMIT ${limit} OFFSET ${offset}
        </if>
    </select>

</mapper>