<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.safeone.dashboard.dao.ModifySensorMapper">
    <sql id="rowSearch">
        <if test="asset_kind_id != null and asset_kind_id != ''">
            and MG.asset_kind_id = #{asset_kind_id}
        </if>
        <if test="name != null and name != ''">
            and MG.name ilike '%' || #{name} || '%'
        </if>
        <if test="zone_id != null and zone_id != ''">
            and MG.zone_id = #{zone_id}
        </if>
        <if test="zone_name != null and zone_name != ''">
            and MG.zone_name ilike #{zone_name} || '%'
        </if>
        <if test="install_date_start != null and install_date_start != '' and install_date_end != null and install_date_end != ''">
            and MG.install_date::timestamp between concat(#{install_date_start},' 00:00:00')::timestamp and
            concat(#{install_date_end},' 23:59:59')::timestamp
        </if>
        <if test="collect_date_start != null and collect_date_start != '' and collect_date_end != null and collect_date_end != ''">
            and to_date(MG.collect_date, 'YYYY-MM-DD') between #{collect_date_start}::date and #{collect_date_end}::date
        </if>
        <if test="status != null and status != ''">
            and MG.status ilike '%' || #{status} || '%'
        </if>
        <if test="real_value != null and real_value != ''">
            and MG.real_value ilike '%' || #{real_value} || '%'
        </if>
    </sql>

    <sql id="rowOrder">
        <trim prefix="order by">
            <choose>
                <when test="'asset_kind_id' == sidx and sidx != ''">
                    MG.asset_kind_id ${sord}
                </when>
                <when test="'name' == sidx and sidx != ''">
                    MG.name ${sord}
                </when>
                <when test="'zone_id' == sidx and sidx != ''">
                    MG.zone_id ${sord}
                </when>
                <when test="'zone_name' == sidx and sidx != ''">
                    MG.zone_name ${sord}
                </when>
                <when test="'install_date' == sidx and sidx != ''">
                    MG.install_date ${sord}
                </when>
                <when test="'collect_date' == sidx and sidx != ''">
                    MG.collect_date ${sord}
                </when>
                <when test="'status' == sidx and sidx != ''">
                    MG.status ${sord}
                </when>
                <when test="'value' == sidx and sidx != ''">
                    MG.value ${sord}
                </when>
                <when test="'real_value' == sidx and sidx != ''">
                    MG.real_value ${sord}
                </when>
                <otherwise>
                    MG.zone_id, MG.name
                </otherwise>
            </choose>
        </trim>
    </sql>

    <sql id="chRowSearch">
        <if test="asset_kind_id != null and asset_kind_id != ''">
            and MG.asset_kind_id = #{asset_kind_id}
        </if>
        <if test="name != null and name != ''">
            and MG.name ilike '%' || #{name} || '%'
        </if>
        <if test="zone_id != null and zone_id != ''">
            and MG.zone_id = #{zone_id}
        </if>
        <if test="zone_name != null and zone_name != ''">
            and MG.zone_name ilike '%' || #{zone_name} || '%'
        </if>
        <if test="install_date != null and install_date != ''">
            and MG.install_date ilike '%' || #{install_date} || '%'
        </if>
        <if test="ch_collect_date_start != null and ch_collect_date_start != '' and ch_collect_date_end != null and ch_collect_date_end != ''">
            and to_date(MG.ch_collect_date, 'YYYY-MM-DD') between #{ch_collect_date_start}::date and
            #{ch_collect_date_end}::date
        </if>
        <if test="status != null and status != ''">
            and MG.status ilike '%' || #{status} || '%'
        </if>
        <if test="real_value != null and real_value != ''">
            and MG.real_value ilike '%' || #{real_value} || '%'
        </if>
    </sql>

    <sql id="chRowOrder">
        <trim prefix="order by">
            <choose>
                <when test="'asset_kind_id' == sidx and sidx != ''">
                    MG.asset_kind_id ${sord}
                </when>
                <when test="'name' == sidx and sidx != ''">
                    MG.name ${sord}
                </when>
                <when test="'zone_id' == sidx and sidx != ''">
                    MG.zone_id ${sord}
                </when>
                <when test="'zone_name' == sidx and sidx != ''">
                    MG.zone_name ${sord}
                </when>
                <when test="'install_date' == sidx and sidx != ''">
                    MG.install_date ${sord}
                </when>
                <when test="'ch_collect_date' == sidx and sidx != ''">
                    MG.ch_collect_date ${sord}
                </when>
                <when test="'status' == sidx and sidx != ''">
                    MG.status ${sord}
                </when>
                <when test="'value' == sidx and sidx != ''">
                    MG.value ${sord}
                </when>
                <when test="'real_value' == sidx and sidx != ''">
                    MG.real_value ${sord}
                </when>
                <otherwise>
                    MG.zone_id, MG.name
                </otherwise>
            </choose>
        </trim>
    </sql>

    <select id="selectGroupSensorList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT MG.*
        FROM (
        SELECT
        ass.*
        , zo.name as zone_name
        FROM (
        select
        tak.name as asset_kind_name,
        tak.asset_kind_id,
        ta.asset_id,
        ta."name",
        ta.status,
        TO_CHAR(TO_TIMESTAMP(MAX(dbc.collect_date) , 'YYYY/MM/DD HH24:MI:SS'), 'YYYY/MM/DD HH24:MI:SS') as collect_date,
        ta.zone_id
        from tb_asset ta
        left join tb_asset_kind tak on ta.asset_kind_id = tak.asset_kind_id
        LEFT outer join tb_channel ch ON ta.asset_id = ch.asset_id
        left outer join
        (
        SELECT *
        FROM tb_dps_basecollection
        WHERE (sensor_id, zone_id, collect_date)
        IN ( SELECT sensor_id, zone_id, MAX(collect_date)
        FROM tb_dps_basecollection
        GROUP BY sensor_id, zone_id )
        ) dbc on ch.sensor_id = dbc.sensor_id and ch.zone_id = dbc.zone_id
        where ta.asset_kind_id IN ('2','3','4','6','7')
        group by tak.name, tak.asset_kind_id, ta.asset_id, ta."name", ta.status
        order by ta.asset_kind_id desc
        ) ass
        LEFT JOIN tb_zone zo ON zo.zone_id = ass.zone_id
        WHERE zo.use_flag = 'Y'
        ) MG
        WHERE 1=1
        <include refid="rowSearch"/>
        <include refid="rowOrder"/>
        <if test="page != null and page > 0">
            limit #{rows}::int offset (#{page}::int - 1) * #{rows}::int
        </if>
        <if test="limit != null and !limit.equals('') and offset != null and !offset.equals('')">
            LIMIT ${limit} OFFSET ${offset}
        </if>
    </select>

    <select id="selectGroupSensorTotal" parameterType="java.util.Map" resultType="int">
        SELECT count(1)
        FROM (
        SELECT
        ass.*
        , zo.name as zone_name
        FROM (
        select
        tak.name as asset_kind_name,
        tak.asset_kind_id,
        ta.asset_id,
        ta."name",
        ta.status,
        TO_CHAR(TO_TIMESTAMP(MAX(dbc.collect_date) , 'YYYY/MM/DD HH24:MI:SS'), 'YYYY/MM/DD HH24:MI:SS') as collect_date,
        ta.zone_id
        from tb_asset ta
        left join tb_asset_kind tak on ta.asset_kind_id = tak.asset_kind_id
        LEFT outer join tb_channel ch ON ta.asset_id = ch.asset_id
        left outer join
        (
        SELECT *
        FROM tb_dps_basecollection
        WHERE (sensor_id, zone_id, collect_date)
        IN ( SELECT sensor_id, zone_id, MAX(collect_date)
        FROM tb_dps_basecollection
        GROUP BY sensor_id, zone_id )
        ) dbc on ch.sensor_id = dbc.sensor_id and ch.zone_id = dbc.zone_id
        where ta.asset_kind_id IN ('2','3','4','6','7')
        group by tak.name, tak.asset_kind_id, ta.asset_id, ta."name", ta.status
        order by ta.asset_kind_id desc
        ) ass
        LEFT JOIN tb_zone zo ON zo.zone_id = ass.zone_id
        WHERE zo.use_flag = 'Y'
        ) MG
        WHERE 1=1
        <include refid="rowSearch"/>
    </select>

    <select id="selectSensorList" parameterType="java.util.Map" resultType="java.util.Map">
        select *
        from (WITH lag_rank_data AS (SELECT sens_no,
        sens_chnl_id,
        meas_dt,
        formul_data,
        LAG(meas_dt, 1)
        OVER (PARTITION BY sens_no, sens_chnl_id ORDER BY meas_dt)      AS prev_meas_dt, -- 이전 행의 meas_dt
        ROW_NUMBER()
        OVER (PARTITION BY sens_no, sens_chnl_id ORDER BY meas_dt DESC) AS rn            -- 각 그룹에서 가장 최신 데이터에 순위 1을 부여
        FROM (SELECT * FROM tb_measure_details ORDER BY meas_dt desc LIMIT 1000) a -- LIMIT는  전체센서수(채널수)를 충분히 넘게 설정
        ),
        latest_meas_details AS (SELECT sens_no,
        sens_chnl_id,
        meas_dt,
        prev_meas_dt,
        formul_data,
--         EXTRACT(EPOCH FROM (meas_dt - prev_meas_dt)) / 60     AS diff_min, -- -- 최신 데이터와 직전 데이터의 시간 차이를 분 단위로 계산
--         EXTRACT(EPOCH FROM (meas_dt - prev_meas_dt)) / 60 - 1 AS err_cnt
        EXTRACT(EPOCH FROM (now() - meas_dt)) / 60     AS diff_min, -- test
        EXTRACT(EPOCH FROM (now() - meas_dt)) / 60 - 1 AS err_cnt -- test
        FROM lag_rank_data
        WHERE rn = 1
        AND prev_meas_dt IS NOT NULL -- 이전 데이터가 있는 경우만 계산
        )

        select
        --   c.district_no
        a.district_nm
        , a.sens_no
        , a.senstype_no
        , a.sens_tp_nm
        , a.sens_nm
        , a.sens_chnl_nm
        , a.logr_nm
        , a.sect_no
        , a.inst_ymd
        , a.latest_meas_dt
        , coalesce(c.maint_rslt_cd, 'MTN001') AS sens_status -- 센서상태
        , a.comm_status                       AS comm_status -- 통신상태
        , a.formul_data
        , CASE
        WHEN a.formul_data &lt;= b."1st_lvl_min" OR a.formul_data >= b."1st_lvl_max" THEN b."1st_lvl_nm"
        WHEN a.formul_data &lt;= b."2nd_lvl_min" OR a.formul_data >= b."2nd_lvl_max" THEN b."2nd_lvl_nm"
        WHEN a.formul_data &lt;= b."3rd_lvl_min" OR a.formul_data >= b."3rd_lvl_max" THEN b."3rd_lvl_nm"
        WHEN a.formul_data &lt;= b."4th_lvl_min" OR a.formul_data >= b."4th_lvl_max" THEN b."4th_lvl_nm"
        ELSE '정상' END                   as alram_lvl
        from (SELECT a.sens_no
        , a.senstype_no
        , e.sens_chnl_id
        , c.district_no
        , c.district_nm
        , d.sens_tp_nm
        , a.sens_nm
        , e.sens_chnl_nm
        , b.logr_nm
        , a.sect_no
        , TO_CHAR(TO_DATE(a.inst_ymd, 'YYYYMMDD'), 'YYYY-MM-DD') AS inst_ymd
        , lmd.meas_dt                                                           as latest_meas_dt
        -- ,    case when lmd.diff_min = 1 then '통신정상' else '통신이상' end as net_staus  -- 통신상태
        --    ,   coalesce(sst.maint_rslt_cd, 'MTN001') as sens_status  -- 센서상태 (유지보수테이블에서 센서상태를 체크)
        -- ,    lmd.err_cnt as delay_min  -- 지연시간(분)
        , case when lmd.err_cnt >= a.nonrecv_limit_min then '미수신' else '수신' end as comm_status -- 통신상태 (센서정보의 미수신시간을 체크)
        , lmd.formul_data
        FROM tb_sensor_info a,
        tb_logger_info b,
        tb_district_info c,
        tb_sensor_type d,
        tb_sensor_chnl e,
        latest_meas_details lmd
        WHERE a.logr_no = b.logr_no
        AND b.district_no = c.district_no
        AND a.senstype_no = d.senstype_no
        AND a.sens_no = e.sens_no
        AND e.sens_no = lmd.sens_no
        AND e.sens_chnl_id = lmd.sens_chnl_id) a
        LEFT OUTER JOIN
        (SELECT *
        from tb_alarm_info
        WHERE "1st_lvl_min" != 0) b
        ON a.sens_no = b.sens_no
        AND a.sens_chnl_id = b.sens_chnl_id
        left outer join
        (SELECT sens_no, maint_rslt_cd
        FROM tb_maint_details
        WHERE (sens_no, maint_accpt_ymd) IN
        (SELECT sens_no, MAX(maint_accpt_ymd) max_accpt_ymd FROM tb_maint_details GROUP BY sens_no)) c
        on a.sens_no = c.sens_no) as final_result
        WHERE 1=1
        <if test="limit != null and !limit.equals('') and offset != null and !offset.equals('')">
            LIMIT ${limit} OFFSET ${offset}
        </if>
    </select>

    <select id="selectSensorListTotal" parameterType="java.util.Map" resultType="int">
        select count(*)
        from (WITH lag_rank_data AS (SELECT sens_no,
        sens_chnl_id,
        meas_dt,
        formul_data,
        LAG(meas_dt, 1)
        OVER (PARTITION BY sens_no, sens_chnl_id ORDER BY meas_dt)      AS prev_meas_dt, -- 이전 행의 meas_dt
        ROW_NUMBER()
        OVER (PARTITION BY sens_no, sens_chnl_id ORDER BY meas_dt DESC) AS rn            -- 각 그룹에서 가장 최신 데이터에 순위 1을 부여
        FROM (SELECT * FROM tb_measure_details ORDER BY meas_dt desc LIMIT 1000) a -- LIMIT는  전체센서수(채널수)를 충분히 넘게 설정
        ),
        latest_meas_details AS (SELECT sens_no,
        sens_chnl_id,
        meas_dt,
        prev_meas_dt,
        formul_data,
        EXTRACT(EPOCH FROM (meas_dt - prev_meas_dt)) / 60     AS diff_min, -- -- 최신 데이터와 직전 데이터의 시간 차이를 분 단위로 계산
        EXTRACT(EPOCH FROM (meas_dt - prev_meas_dt)) / 60 - 1 AS err_cnt
        FROM lag_rank_data
        WHERE rn = 1
        AND prev_meas_dt IS NOT NULL -- 이전 데이터가 있는 경우만 계산
        )
        select
        --   c.district_no
        a.district_nm
        , a.sens_tp_nm
        , a.sens_nm
        , a.sens_chnl_nm
        , a.logr_nm                                          --   , a.sect_no, a.inst_ymd
        , a.latest_meas_dt
        , coalesce(c.maint_rslt_cd, 'MTN001') AS sens_status -- 센서상태
        , a.comm_status                       AS comm_status -- 통신상태
        , a.formul_data
        , CASE
        WHEN a.formul_data &lt;= b."1st_lvl_min" OR a.formul_data >= b."1st_lvl_max" THEN b."1st_lvl_nm"
        WHEN a.formul_data &lt;= b."2nd_lvl_min" OR a.formul_data >= b."2nd_lvl_max" THEN b."2nd_lvl_nm"
        WHEN a.formul_data &lt;= b."3rd_lvl_min" OR a.formul_data >= b."3rd_lvl_max" THEN b."3rd_lvl_nm"
        WHEN a.formul_data &lt;= b."4th_lvl_min" OR a.formul_data >= b."4th_lvl_max" THEN b."4th_lvl_nm"
        ELSE '정상' END                   as alram_lvl
        from (SELECT a.sens_no
        , e.sens_chnl_id
        , c.district_no
        , c.district_nm
        , d.sens_tp_nm
        , a.sens_nm
        , e.sens_chnl_nm
        , b.logr_nm
        , a.sect_no
        , a.inst_ymd
        , lmd.meas_dt                                                           as latest_meas_dt
        -- ,    case when lmd.diff_min = 1 then '통신정상' else '통신이상' end as net_staus  -- 통신상태
        --    ,   coalesce(sst.maint_rslt_cd, 'MTN001') as sens_status  -- 센서상태 (유지보수테이블에서 센서상태를 체크)
        -- ,    lmd.err_cnt as delay_min  -- 지연시간(분)
        , case when lmd.err_cnt >= a.nonrecv_limit_min then '미수신' else '수신' end as comm_status -- 통신상태 (센서정보의 미수신시간을 체크)
        , lmd.formul_data
        FROM tb_sensor_info a,
        tb_logger_info b,
        tb_district_info c,
        tb_sensor_type d,
        tb_sensor_chnl e,
        latest_meas_details lmd
        WHERE a.logr_no = b.logr_no
        AND b.district_no = c.district_no
        AND a.senstype_no = d.senstype_no
        AND a.sens_no = e.sens_no
        AND e.sens_no = lmd.sens_no
        AND e.sens_chnl_id = lmd.sens_chnl_id) a
        LEFT OUTER JOIN
        (SELECT *
        from tb_alarm_info
        WHERE "1st_lvl_min" != 0) b
        ON a.sens_no = b.sens_no
        AND a.sens_chnl_id = b.sens_chnl_id
        left outer join
        (SELECT sens_no, maint_rslt_cd
        FROM tb_maint_details
        WHERE (sens_no, maint_accpt_ymd) IN
        (SELECT sens_no, MAX(maint_accpt_ymd) max_accpt_ymd FROM tb_maint_details GROUP BY sens_no)) c
        on a.sens_no = c.sens_no) as final_result
        WHERE 1=1
    </select>

    <select id="selectSensorByChannelList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT MG.*
        FROM (
        SELECT ass.asset_id
        , ass.asset_kind_id
        , ass.asset_kind_id as asset_kind_id_hid
        , ass.name
        -- , '' ch_name
        -- , '' sensor_id
        , ARRAY_TO_STRING(ARRAY_AGG(ch.name||':'||ch.sensor_id||':'||ch.zone_id),',') as ch_name_sensor_keys
        -- , ARRAY_TO_STRING(ARRAY_AGG(ch.sensor_id),',') sensor_ids
        , ass.zone_id
        , ass.status
        , TO_CHAR(ass.install_date::timestamp, 'YYYY-MM-DD') AS install_date
        , TO_CHAR(TO_TIMESTAMP(MAX(dbc.collect_date) , 'YYYY/MM/DD HH24:MI:SS'), 'YYYY/MM/DD HH24:MI:SS') as
        ch_collect_date
        , MAX(dbc.real_value) real_value
        , (select name from tb_zone WHERE zone_id = ass.zone_id) as zone_name
        FROM tb_asset ass
        LEFT JOIN tb_channel ch ON ass.asset_id = ch.asset_id
        LEFT JOIN (SELECT *
        FROM tb_dps_basecollection
        WHERE (sensor_id, zone_id, collect_date)
        IN ( SELECT sensor_id, zone_id, MAX(collect_date)
        FROM tb_dps_basecollection
        GROUP BY sensor_id, zone_id )
        ) dbc ON ch.sensor_id = dbc.sensor_id and ch.zone_id = dbc.zone_id
        WHERE ass.asset_kind_id IN ('2','3','4','6','7')
        GROUP BY ass.asset_id, ass.asset_kind_id,ass.name, ass.zone_id, ass.status, ass.install_date
        ) MG
        LEFT JOIN tb_zone zo ON zo.zone_id = MG.zone_id
        WHERE 1=1
        and zo.use_flag = 'Y'
        <include refid="chRowSearch"/>
        <include refid="chRowOrder"/>
        <if test="page != null and page > 0">
            limit #{rows}::int offset (#{page}::int - 1) * #{rows}::int
        </if>
    </select>

    <select id="selectSensorByChannelListTotal" parameterType="java.util.Map" resultType="int">
        -- selectSensorByChannelListTotal
        SELECT count(1)
        FROM (
        SELECT ass.asset_kind_id
        , ass.asset_kind_id as asset_kind_id_hid
        , ass.name
        -- , '' ch_name
        -- , '' sensor_id
        , ARRAY_TO_STRING(ARRAY_AGG(ch.name||':'||ch.sensor_id||':'||ch.zone_id),',') as ch_name_sensor_keys
        -- , ARRAY_TO_STRING(ARRAY_AGG(ch.sensor_id),',') sensor_ids
        , ass.zone_id
        , ass.status
        , TO_CHAR(ass.install_date::timestamp, 'YYYY-MM-DD') AS install_date
        , TO_CHAR(TO_TIMESTAMP(MAX(dbc.collect_date) , 'YYYY/MM/DD HH24:MI:SS'), 'YYYY/MM/DD HH24:MI:SS') as
        ch_collect_date
        , MAX(dbc.real_value) as real_value
        , (select name from tb_zone WHERE zone_id = ass.zone_id) as zone_name
        FROM tb_asset ass
        LEFT JOIN tb_channel ch ON ass.asset_id = ch.asset_id
        LEFT JOIN (SELECT *
        FROM tb_dps_basecollection
        WHERE (sensor_id, zone_id, collect_date)
        IN ( SELECT sensor_id, zone_id, MAX(collect_date)
        FROM tb_dps_basecollection
        GROUP BY sensor_id, zone_id )
        ) dbc ON ch.sensor_id = dbc.sensor_id and ch.zone_id = dbc.zone_id
        WHERE ass.asset_kind_id IN ('2','3','4','6','7')
        GROUP BY ass.asset_id, ass.asset_kind_id,ass.name, ass.zone_id, ass.status, ass.install_date
        ) MG
        LEFT JOIN tb_zone zo ON zo.zone_id = MG.zone_id
        WHERE 1=1
        and zo.use_flag = 'Y'
        <include refid="chRowSearch"/>
    </select>

    <select id="getDistinctDistrict" parameterType="java.util.Map" resultType="java.util.Map">
        /* getDistinctDistrict */
        SELECT DISTINCT district_nm
        FROM tb_district_info
        ORDER BY district_nm ASC
    </select>

    <select id="getDistinctSensorType" parameterType="java.util.Map" resultType="java.util.Map">
        /* getDistinctSensorType */
        SELECT DISTINCT sens_tp_nm
        FROM tb_sensor_type
        ORDER BY sens_tp_nm ASC
    </select>

    <select id="getSimpleTotalCount" parameterType="java.util.Map" resultType="int">
        select count(tsi.sens_no)
        from tb_sensor_info tsi
    </select>

    <select id="getAll" parameterType="java.util.Map" resultType="com.safeone.dashboard.dto.MeasureDetailsDto">
        SELECT tsinfo.sens_nm,
               tsinfo.sect_no,
               tsinfo.maint_sts_cd,
               MAX(tst.sens_tp_nm)    AS sens_tp_nm,
               MAX(tsi.formul_data)   AS formul_data,
               MIN(tsi.init_apply_dt) AS init_apply_dt,
               MAX(tsi.last_apply_dt) AS last_apply_dt,
               MAX(tsi.emer_status)   AS emer_status,
               tsinfo.sens_no,
               MAX(tsi.sens_chnl_id)  AS sens_chnl_id
        FROM tb_sensor_info tsinfo
                 LEFT JOIN tb_sensor_init tsi
                           ON tsinfo.sens_no = tsi.sens_no
                 LEFT JOIN tb_sensor_type tst
                           ON tsinfo.senstype_no = tst.senstype_no
        WHERE 1 = 1
          and tst.senstype_no = #{senstype_no}
          and tsinfo.sens_no IN (SELECT tlim.sens_no
                                 FROM tb_logr_idx_map tlim
                                 WHERE tlim.logr_no IN (SELECT tli.logr_no
                                                        FROM tb_district_info tdi
                                                                 LEFT JOIN tb_logger_info tli
                                                                           ON tli.district_no = tdi.district_no
                                                        WHERE tdi.district_no = #{district_no}))
        GROUP BY tsinfo.sens_nm, tsinfo.sens_no;
    </select>
</mapper>