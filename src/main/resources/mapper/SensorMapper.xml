<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.safeone.dashboard.dao.ModifySensorMapper">
    <sql id="rowSearch">
        <if test="asset_kind_id != null and asset_kind_id != ''">
            and MG.asset_kind_id = #{asset_kind_id}
        </if>
        <if test="name != null and name != ''">
            and MG.name ilike '%' || #{name} || '%'
        </if>
        <if test="zone_id != null and zone_id != ''">
            and MG.zone_id = #{zone_id}
        </if>
        <if test="zone_name != null and zone_name != ''">
            and MG.zone_name ilike #{zone_name} || '%'
        </if>
        <if test="install_date_start != null and install_date_start != '' and install_date_end != null and install_date_end != ''">
            and MG.install_date::timestamp between concat(#{install_date_start},' 00:00:00')::timestamp and
            concat(#{install_date_end},' 23:59:59')::timestamp
        </if>
        <if test="collect_date_start != null and collect_date_start != '' and collect_date_end != null and collect_date_end != ''">
            and to_date(MG.collect_date, 'YYYY-MM-DD') between #{collect_date_start}::date and #{collect_date_end}::date
        </if>
        <if test="status != null and status != ''">
            and MG.status ilike '%' || #{status} || '%'
        </if>
        <if test="real_value != null and real_value != ''">
            and MG.real_value ilike '%' || #{real_value} || '%'
        </if>
    </sql>

    <sql id="rowOrder">
        <trim prefix="order by">
            <choose>
                <when test="'asset_kind_id' == sidx and sidx != ''">
                    MG.asset_kind_id ${sord}
                </when>
                <when test="'name' == sidx and sidx != ''">
                    MG.name ${sord}
                </when>
                <when test="'zone_id' == sidx and sidx != ''">
                    MG.zone_id ${sord}
                </when>
                <when test="'zone_name' == sidx and sidx != ''">
                    MG.zone_name ${sord}
                </when>
                <when test="'install_date' == sidx and sidx != ''">
                    MG.install_date ${sord}
                </when>
                <when test="'collect_date' == sidx and sidx != ''">
                    MG.collect_date ${sord}
                </when>
                <when test="'status' == sidx and sidx != ''">
                    MG.status ${sord}
                </when>
                <when test="'value' == sidx and sidx != ''">
                    MG.value ${sord}
                </when>
                <when test="'real_value' == sidx and sidx != ''">
                    MG.real_value ${sord}
                </when>
                <otherwise>
                    MG.zone_id, MG.name
                </otherwise>
            </choose>
        </trim>
    </sql>

    <sql id="chRowSearch">
        <if test="asset_kind_id != null and asset_kind_id != ''">
            and MG.asset_kind_id = #{asset_kind_id}
        </if>
        <if test="name != null and name != ''">
            and MG.name ilike '%' || #{name} || '%'
        </if>
        <if test="zone_id != null and zone_id != ''">
            and MG.zone_id = #{zone_id}
        </if>
        <if test="zone_name != null and zone_name != ''">
            and MG.zone_name ilike '%' || #{zone_name} || '%'
        </if>
        <if test="install_date != null and install_date != ''">
            and MG.install_date ilike '%' || #{install_date} || '%'
        </if>
        <if test="ch_collect_date_start != null and ch_collect_date_start != '' and ch_collect_date_end != null and ch_collect_date_end != ''">
            and to_date(MG.ch_collect_date, 'YYYY-MM-DD') between #{ch_collect_date_start}::date and
            #{ch_collect_date_end}::date
        </if>
        <if test="status != null and status != ''">
            and MG.status ilike '%' || #{status} || '%'
        </if>
        <if test="real_value != null and real_value != ''">
            and MG.real_value ilike '%' || #{real_value} || '%'
        </if>
    </sql>

    <sql id="chRowOrder">
        <trim prefix="order by">
            <choose>
                <when test="'asset_kind_id' == sidx and sidx != ''">
                    MG.asset_kind_id ${sord}
                </when>
                <when test="'name' == sidx and sidx != ''">
                    MG.name ${sord}
                </when>
                <when test="'zone_id' == sidx and sidx != ''">
                    MG.zone_id ${sord}
                </when>
                <when test="'zone_name' == sidx and sidx != ''">
                    MG.zone_name ${sord}
                </when>
                <when test="'install_date' == sidx and sidx != ''">
                    MG.install_date ${sord}
                </when>
                <when test="'ch_collect_date' == sidx and sidx != ''">
                    MG.ch_collect_date ${sord}
                </when>
                <when test="'status' == sidx and sidx != ''">
                    MG.status ${sord}
                </when>
                <when test="'value' == sidx and sidx != ''">
                    MG.value ${sord}
                </when>
                <when test="'real_value' == sidx and sidx != ''">
                    MG.real_value ${sord}
                </when>
                <otherwise>
                    MG.zone_id, MG.name
                </otherwise>
            </choose>
        </trim>
    </sql>

    <select id="selectGroupSensorList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT MG.*
        FROM (
        SELECT
        ass.*
        , zo.name as zone_name
        FROM (
        select
        tak.name as asset_kind_name,
        tak.asset_kind_id,
        ta.asset_id,
        ta."name",
        ta.status,
        TO_CHAR(TO_TIMESTAMP(MAX(dbc.collect_date) , 'YYYY/MM/DD HH24:MI:SS'), 'YYYY/MM/DD HH24:MI:SS') as collect_date,
        ta.zone_id
        from tb_asset ta
        left join tb_asset_kind tak on ta.asset_kind_id = tak.asset_kind_id
        LEFT outer join tb_channel ch ON ta.asset_id = ch.asset_id
        left outer join
        (
        SELECT *
        FROM tb_dps_basecollection
        WHERE (sensor_id, zone_id, collect_date)
        IN ( SELECT sensor_id, zone_id, MAX(collect_date)
        FROM tb_dps_basecollection
        GROUP BY sensor_id, zone_id )
        ) dbc on ch.sensor_id = dbc.sensor_id and ch.zone_id = dbc.zone_id
        where ta.asset_kind_id IN ('2','3','4','6','7')
        group by tak.name, tak.asset_kind_id, ta.asset_id, ta."name", ta.status
        order by ta.asset_kind_id desc
        ) ass
        LEFT JOIN tb_zone zo ON zo.zone_id = ass.zone_id
        WHERE zo.use_flag = 'Y'
        ) MG
        WHERE 1=1
        <include refid="rowSearch"/>
        <include refid="rowOrder"/>
        <if test="page != null and page > 0">
            limit #{rows}::int offset (#{page}::int - 1) * #{rows}::int
        </if>
        <if test="limit != null and !limit.equals('') and offset != null and !offset.equals('')">
            LIMIT ${limit} OFFSET ${offset}
        </if>
    </select>

    <select id="selectGroupSensorTotal" parameterType="java.util.Map" resultType="int">
        SELECT count(1)
        FROM (
        SELECT
        ass.*
        , zo.name as zone_name
        FROM (
        select
        tak.name as asset_kind_name,
        tak.asset_kind_id,
        ta.asset_id,
        ta."name",
        ta.status,
        TO_CHAR(TO_TIMESTAMP(MAX(dbc.collect_date) , 'YYYY/MM/DD HH24:MI:SS'), 'YYYY/MM/DD HH24:MI:SS') as collect_date,
        ta.zone_id
        from tb_asset ta
        left join tb_asset_kind tak on ta.asset_kind_id = tak.asset_kind_id
        LEFT outer join tb_channel ch ON ta.asset_id = ch.asset_id
        left outer join
        (
        SELECT *
        FROM tb_dps_basecollection
        WHERE (sensor_id, zone_id, collect_date)
        IN ( SELECT sensor_id, zone_id, MAX(collect_date)
        FROM tb_dps_basecollection
        GROUP BY sensor_id, zone_id )
        ) dbc on ch.sensor_id = dbc.sensor_id and ch.zone_id = dbc.zone_id
        where ta.asset_kind_id IN ('2','3','4','6','7')
        group by tak.name, tak.asset_kind_id, ta.asset_id, ta."name", ta.status
        order by ta.asset_kind_id desc
        ) ass
        LEFT JOIN tb_zone zo ON zo.zone_id = ass.zone_id
        WHERE zo.use_flag = 'Y'
        ) MG
        WHERE 1=1
        <include refid="rowSearch"/>
    </select>

    <select id="selectSensorList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT
            c.district_nm,
            a.sens_no,
            a.senstype_no,
            d.sens_tp_nm,
            a.sens_nm,
            e.sens_chnl_nm,
            b.logr_nm,
            a.sect_no,
            TO_CHAR(TO_DATE(a.inst_ymd, 'YYYYMMDD'), 'YYYY-MM-DD') AS inst_ymd,
            lmd.meas_dt AS latest_meas_dt,
            COALESCE(m.maint_rslt_cd, 'MTN001') AS sens_status,
            CASE
            WHEN COALESCE(lmd.err_cnt, 999999) >= a.nonrecv_limit_min THEN '미수신'
                ELSE '수신'
            END AS comm_status,
            lmd.raw_data AS raw_data,
            (CAST(lmd.raw_data AS DOUBLE PRECISION) - CAST(tsi.init_raw_data AS DOUBLE PRECISION)) AS disp_val,
            lmd.formul_data
        FROM tb_sensor_info a
        JOIN tb_logger_info b ON a.logr_no = b.logr_no
        JOIN tb_district_info c ON b.district_no = c.district_no
        JOIN tb_sensor_type d ON a.senstype_no = d.senstype_no
        JOIN tb_sensor_chnl e ON a.sens_no = e.sens_no
        LEFT JOIN tb_sensor_init tsi ON a.sens_no = tsi.sens_no
        LEFT JOIN LATERAL (
            SELECT
                m.sens_no,
                m.sens_chnl_id, 
                m.meas_dt,
                m.raw_data,
                m.formul_data,
                EXTRACT(EPOCH FROM (now() - m.meas_dt)) / 60 AS diff_min,
                EXTRACT(EPOCH FROM (now() - m.meas_dt)) / 60 - 1 AS err_cnt
            FROM tb_measure_details m
            WHERE m.sens_no = e.sens_no
                AND m.sens_chnl_id = e.sens_chnl_id
            ORDER BY m.meas_dt DESC
            LIMIT 1
        ) AS lmd ON TRUE
        LEFT JOIN (
            SELECT sens_no, maint_rslt_cd
            FROM tb_maint_details
            WHERE (sens_no, maint_accpt_ymd) IN (
                SELECT sens_no, MAX(maint_accpt_ymd)
                FROM tb_maint_details
                GROUP BY sens_no
            )
        ) m ON a.sens_no = m.sens_no
        LEFT JOIN tb_alarm_info ai
            ON a.sens_no = ai.sens_no
            AND e.sens_chnl_id = ai.sens_chnl_id
        WHERE 1=1
        ORDER BY district_nm, senstype_no, sens_no, sens_chnl_nm
        <if test="limit != null and !limit.equals('') and offset != null and !offset.equals('')">
            LIMIT ${limit} OFFSET ${offset}
        </if>
    </select>

    <select id="selectSensorListTotal" parameterType="java.util.Map" resultType="int">
        select count(*) from (SELECT
                                  c.district_nm,
                                  a.sens_no,
                                  a.senstype_no,
                                  d.sens_tp_nm,
                                  a.sens_nm,
                                  e.sens_chnl_nm,
                                  b.logr_nm,
                                  a.sect_no,
                                  TO_CHAR(TO_DATE(a.inst_ymd, 'YYYYMMDD'), 'YYYY-MM-DD') AS inst_ymd,
                                  lmd.meas_dt AS latest_meas_dt,
                                  COALESCE(m.maint_rslt_cd, 'MTN001') AS sens_status,
                                  CASE
                                      WHEN COALESCE(lmd.err_cnt, 999999) >= a.nonrecv_limit_min THEN '미수신'
                                      ELSE '수신'
                                      END AS comm_status,
                                  lmd.formul_data
                              FROM tb_sensor_info a
                                       JOIN tb_logger_info b ON a.logr_no = b.logr_no
                                       JOIN tb_district_info c ON b.district_no = c.district_no
                                       JOIN tb_sensor_type d ON a.senstype_no = d.senstype_no
                                       JOIN tb_sensor_chnl e ON a.sens_no = e.sens_no
                                       LEFT JOIN LATERAL (
                                  SELECT
                                      m.sens_no,
                                      m.sens_chnl_id,
                                      m.meas_dt,
                                      m.formul_data,
                                      EXTRACT(EPOCH FROM (now() - m.meas_dt)) / 60 AS diff_min,
                                      EXTRACT(EPOCH FROM (now() - m.meas_dt)) / 60 - 1 AS err_cnt
                                  FROM tb_measure_details m
                                  WHERE m.sens_no = e.sens_no
                                    AND m.sens_chnl_id = e.sens_chnl_id
                                  ORDER BY m.meas_dt DESC
                                      LIMIT 1
                             ) AS lmd ON TRUE
        LEFT JOIN (
            SELECT sens_no, maint_rslt_cd
            FROM tb_maint_details
            WHERE (sens_no, maint_accpt_ymd) IN (
                SELECT sens_no, MAX(maint_accpt_ymd)
                FROM tb_maint_details
                GROUP BY sens_no
            )
        ) m ON a.sens_no = m.sens_no
            LEFT JOIN tb_alarm_info ai
            ON a.sens_no = ai.sens_no
            AND e.sens_chnl_id = ai.sens_chnl_id
            ) as final
        WHERE 1=1
    </select>

    <select id="selectSensorByChannelList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT MG.*
        FROM (
        SELECT ass.asset_id
        , ass.asset_kind_id
        , ass.asset_kind_id as asset_kind_id_hid
        , ass.name
        -- , '' ch_name
        -- , '' sensor_id
        , ARRAY_TO_STRING(ARRAY_AGG(ch.name||':'||ch.sensor_id||':'||ch.zone_id),',') as ch_name_sensor_keys
        -- , ARRAY_TO_STRING(ARRAY_AGG(ch.sensor_id),',') sensor_ids
        , ass.zone_id
        , ass.status
        , TO_CHAR(ass.install_date::timestamp, 'YYYY-MM-DD') AS install_date
        , TO_CHAR(TO_TIMESTAMP(MAX(dbc.collect_date) , 'YYYY/MM/DD HH24:MI:SS'), 'YYYY/MM/DD HH24:MI:SS') as
        ch_collect_date
        , MAX(dbc.real_value) real_value
        , (select name from tb_zone WHERE zone_id = ass.zone_id) as zone_name
        FROM tb_asset ass
        LEFT JOIN tb_channel ch ON ass.asset_id = ch.asset_id
        LEFT JOIN (SELECT *
        FROM tb_dps_basecollection
        WHERE (sensor_id, zone_id, collect_date)
        IN ( SELECT sensor_id, zone_id, MAX(collect_date)
        FROM tb_dps_basecollection
        GROUP BY sensor_id, zone_id )
        ) dbc ON ch.sensor_id = dbc.sensor_id and ch.zone_id = dbc.zone_id
        WHERE ass.asset_kind_id IN ('2','3','4','6','7')
        GROUP BY ass.asset_id, ass.asset_kind_id,ass.name, ass.zone_id, ass.status, ass.install_date
        ) MG
        LEFT JOIN tb_zone zo ON zo.zone_id = MG.zone_id
        WHERE 1=1
        and zo.use_flag = 'Y'
        <include refid="chRowSearch"/>
        <include refid="chRowOrder"/>
        <if test="page != null and page > 0">
            limit #{rows}::int offset (#{page}::int - 1) * #{rows}::int
        </if>
    </select>

    <select id="selectSensorByChannelListTotal" parameterType="java.util.Map" resultType="int">
        -- selectSensorByChannelListTotal
        SELECT count(1)
        FROM (
        SELECT ass.asset_kind_id
        , ass.asset_kind_id as asset_kind_id_hid
        , ass.name
        -- , '' ch_name
        -- , '' sensor_id
        , ARRAY_TO_STRING(ARRAY_AGG(ch.name||':'||ch.sensor_id||':'||ch.zone_id),',') as ch_name_sensor_keys
        -- , ARRAY_TO_STRING(ARRAY_AGG(ch.sensor_id),',') sensor_ids
        , ass.zone_id
        , ass.status
        , TO_CHAR(ass.install_date::timestamp, 'YYYY-MM-DD') AS install_date
        , TO_CHAR(TO_TIMESTAMP(MAX(dbc.collect_date) , 'YYYY/MM/DD HH24:MI:SS'), 'YYYY/MM/DD HH24:MI:SS') as
        ch_collect_date
        , MAX(dbc.real_value) as real_value
        , (select name from tb_zone WHERE zone_id = ass.zone_id) as zone_name
        FROM tb_asset ass
        LEFT JOIN tb_channel ch ON ass.asset_id = ch.asset_id
        LEFT JOIN (SELECT *
        FROM tb_dps_basecollection
        WHERE (sensor_id, zone_id, collect_date)
        IN ( SELECT sensor_id, zone_id, MAX(collect_date)
        FROM tb_dps_basecollection
        GROUP BY sensor_id, zone_id )
        ) dbc ON ch.sensor_id = dbc.sensor_id and ch.zone_id = dbc.zone_id
        WHERE ass.asset_kind_id IN ('2','3','4','6','7')
        GROUP BY ass.asset_id, ass.asset_kind_id,ass.name, ass.zone_id, ass.status, ass.install_date
        ) MG
        LEFT JOIN tb_zone zo ON zo.zone_id = MG.zone_id
        WHERE 1=1
        and zo.use_flag = 'Y'
        <include refid="chRowSearch"/>
    </select>

    <select id="getDistinctDistrict" parameterType="java.util.Map" resultType="java.util.Map">
        /* getDistinctDistrict */
        SELECT DISTINCT district_nm
        FROM tb_district_info
        ORDER BY district_nm ASC
    </select>

    <select id="getDistinctSensorType" parameterType="java.util.Map" resultType="java.util.Map">
--         SELECT DISTINCT sens_tp_nm
--         FROM tb_sensor_type
--         WHERE sens_chnl_cnt != 0
--         ORDER BY sens_tp_nm ASC
        SELECT DISTINCT tst.sens_tp_nm
        FROM tb_sensor_type tst
        WHERE EXISTS (
            SELECT 1
            FROM tb_sensor_info tsi
            WHERE tsi.senstype_no = tst.senstype_no
          )
        ORDER BY tst.sens_tp_nm ASC;
    </select>

    <select id="getDistinctPartnerComp" parameterType="java.util.Map" resultType="java.util.Map">
        /* getDistinctPartnerComp */
        SELECT DISTINCT D.partner_comp_nm
        FROM tb_cctv_info A
        INNER JOIN tb_maintcomp_info D ON A.partner_comp_id = D.partner_comp_id
        WHERE D.partner_comp_nm IS NOT NULL AND D.partner_comp_nm != ''
        ORDER BY D.partner_comp_nm ASC
    </select>

    <select id="getDistinctLogger" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT DISTINCT logr_nm
        FROM tb_logger_info
        WHERE logr_nm IS NOT NULL AND logr_nm != ''
        ORDER BY logr_nm ASC
    </select>

    <select id="getDistinctSection" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT DISTINCT sect_no
        FROM tb_sensor_info
        WHERE sect_no IS NOT NULL
        ORDER BY sect_no ASC
    </select>

    <select id="getSimpleTotalCount" parameterType="java.util.Map" resultType="int">
        select count(tsi.sens_no)
        from tb_sensor_info tsi
    </select>

    <select id="getAll" parameterType="java.util.Map" resultType="com.safeone.dashboard.dto.MeasureDetailsDto">
        SELECT tsinfo.sens_nm,
               tsinfo.sect_no,
               tsinfo.maint_sts_cd,
               MAX(tst.sens_tp_nm)    AS sens_tp_nm,
               MAX(tsi.formul_data)   AS formul_data,
               MIN(tsi.init_apply_dt) AS init_apply_dt,
               MAX(tsi.last_apply_dt) AS last_apply_dt,
               MAX(tsi.emer_status)   AS emer_status,
               tsinfo.sens_no,
               MAX(tsi.sens_chnl_id)  AS sens_chnl_id
        FROM tb_sensor_info tsinfo
                 LEFT JOIN tb_sensor_init tsi
                           ON tsinfo.sens_no = tsi.sens_no
                 LEFT JOIN tb_sensor_type tst
                           ON tsinfo.senstype_no = tst.senstype_no
        WHERE 1 = 1
          and tst.senstype_no = #{senstype_no}
          and tsinfo.sens_no IN (SELECT tlim.sens_no
                                 FROM tb_logr_idx_map tlim
                                 WHERE tlim.logr_no IN (SELECT tli.logr_no
                                                        FROM tb_district_info tdi
                                                                 LEFT JOIN tb_logger_info tli
                                                                           ON tli.district_no = tdi.district_no
                                                        WHERE tdi.district_no = #{district_no}))
        GROUP BY tsinfo.sens_nm, tsinfo.sens_no;
    </select>

    <select id="selectTotalCountByStatus" resultType="com.safeone.dashboard.dto.SensorCountDto">
        WITH comm AS (
                SELECT
                    a.sens_no,
                    CASE
                        WHEN COALESCE(lmd.err_cnt, 999999) >= a.nonrecv_limit_min THEN '미수신'
                        ELSE '수신'
                        END AS comm_status
                FROM tb_sensor_info a
                         JOIN tb_sensor_chnl e
                              ON a.sens_no = e.sens_no
                         LEFT JOIN LATERAL (
                    SELECT
                        m.sens_no,
                        m.sens_chnl_id,
                        m.meas_dt,
                        m.formul_data,
                        EXTRACT(EPOCH FROM (now() - m.meas_dt)) / 60     AS diff_min,
                        EXTRACT(EPOCH FROM (now() - m.meas_dt)) / 60 - 1 AS err_cnt
                    FROM tb_measure_details m
                    WHERE m.sens_no = e.sens_no
                      AND m.sens_chnl_id = e.sens_chnl_id
                    ORDER BY m.meas_dt DESC
                        LIMIT 1
                ) AS lmd ON TRUE
            WHERE 1=1 and a.sens_disp_yn ='Y'
            group by a.sens_no, comm_status
        )
        SELECT
            COUNT(*)                                                     AS allCnt,
            COUNT(*) FILTER (WHERE comm_status = '미수신')               AS errCnt,
                COUNT(*) FILTER (WHERE comm_status = '수신')                 AS conCnt
        FROM comm;
    </select>

    <select id="getMeasureDetails" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT *
        FROM tb_measure_details
        WHERE sens_no = #{sens_no}
        AND sens_chnl_id = #{og_sens_chnl_id}
        ORDER BY meas_dt DESC
        LIMIT 1
    </select>
</mapper>